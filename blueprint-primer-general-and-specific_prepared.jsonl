{"prompt":" What is blueprint?  ->","completion":" \\n blueprint is a paradigm that lets you write schema code and it can generate code while at the same time giving you the ability to add features, modify code and also support additional functionalities. Because Blueprint outputs an X-Framework compatible project, it's important that you have you are up  to date with the X-Framework basics. \\n\\n\n"}
{"prompt":" How to get started with blueprint? ->","completion":" To get directly into try-ing it: npm i -g @bluelibs\/xxChoose x:project and create your new project:cd projectnpm installYou will notice a blueprint\/index.ts file which only has Users collection setup. To generate the project:npm run blueprint:generateThis will generate:Server-side: Collections, Models, GraphQL Types, GraphQL CRUDs, Queries and Mutations for CRUDsCustom GraphQL Inputs, Subscription & Live Data ReadyClient-side:UI Collections, For Isomorphic Interaction with MongoDB, CRUD Admin Pages, Lists with Search, Pagination and Complex Filters, Edit Forms, Create Forms, Easy DeletionNOTEYou can use the x command to generate collections and shared models inside Blueprint: blueprint:collection and blueprint:shared-model \\n\\n\n"}
{"prompt":" Describe how to create and work with collections in blueprint:  ->","completion":" Collections: ​Let's start from scratch with a simple blueprint to walk you through the main concepts. \\n blueprint\/index.ts import { Studio } from \"@bluelibs\/x\"; \\n  import * as faker from \"faker\"; \\n const { generateProject, app, collection, field, relation, sharedModel } =   Studio; \\n  const application = app({   id: \"my-app\",   collections: [     \/\/ Here you will store your collections     collection({       id: \"Posts\",       description: \"What is this collection for\", \/\/ optional  fields: [  \/\/ Here we specify the fields for collection  field({  id: \"title\",  type: fields.types.STRING, }), ], }),  ], });  \/\/ This is what triggers the generation of the project generateProject(application);  \\n NOTE By default all collections and fields are ui aware and exposed in the GraphQL API. To disable this behavior  for collections or fields:  collection({   id: \"Posts\",   ui: false,   enableGraphQL: false, }); \\n GraphQL​ We generate GraphQL entities (models reflecting the ones from the database) and GraphQL Module CRUDs which  allow us to interact easily with the server. If you do not want to have CRUD only, but you need the Entity because it's maybe used by some other entites:  collection({   \/\/ ...   enableGraphQL: {     entity: true,     crud: false,   }, });  \/\/ Using enableGraphQL: true, will enable both \/\/ Using enableGraphQL: false, will disable both NOTE Having entity false, will not create UI Collections, because those collections would have interacted with the  CRUD endpoints created. \\n\\n\n"}
{"prompt":" What are behaviors and how to work with behaviors in blueprint?  ->","completion":" Behaviors​: This refers to the capability to add Collection Behaviors from MongoBundle  Be careful with behaviors as they are generated only once, if you want to add a specific behavior after you  generated, you either delete the collection file, either add it yourself manually to the collection.  collection({   id: \"Users\",   behaviors: {     timestampable: true, softdeletable: true,   }, }); Typically these behaviors also have shortcuts so you can easily configure things like blameable relations or  timestampable fields. \\n\\n\n"}
{"prompt":" What are fields and how to work with basic fields in blueprint?  ->","completion":" Fields​:  Fields are essential to describing how your collection model looks like, inside fields we can store  relational data (ids from other collections) or any other supported primitive. Fields can also have subfields  which translates in the output as a nested object.  The typical field looks like this:  field({   id: \"variableName\",   type: field.types.STRING,    \/\/ Optionals   description: \"What is this field for?\", \/\/ This would be stored as a comment for both models and 'GraphQL'    entities and will be shown as helper text inside the forms   isArray: false, \/\/ (default: false) whether it's an array of elements   isRequired: true, \/\/ (default: true)   enableGraphQL: true, \/\/ (default: true) would this field be present in the API? For example if you store a    password hash, then most likely not.   \/\/ Disable all UI by saying ui: false   ui: {     label: \"Variable Name\", \/\/ How it is presented in the field     order: number,     list: true, \/\/ Whether this is presented in the list table of elements     listFilters: true, \/\/ Whether you can filter by it     view: true, \/\/ Whether it's present in the view     edit: true, \/\/ Whether it's present in the edit form     create: true, \/\/ Wheter it's present in the create form,     form: {       component: \"Input.TextArea\", \/\/ This supports every data entry from Ant       props: {}, \/\/ Additional props to pass the component like sizes or etc.     },   }, }); The available field types:  export enum FieldValueKind {   OBJECT_ID = \"objectId\",   STRING = \"string\",   ENUM = \"enum\",   INTEGER = \"integer\",   FLOAT = \"float\",   DATE = \"date\",   BOOLEAN = \"boolean\",   OBJECT = \"object\", } Shortcuts​ \/\/ Making it super straight forward to avoid { id, type } field.string(\"firstName\"); \/\/ Add additional options to it field.string(\"lastName\", { isRequired: true });  \/\/ And the rest of the crowd field.objectId(\"id\"); field.enum(\"id\"); field.integer(\"id\"); field.float(\"id\"); field.date(\"id\"); field.boolean(\"id\"); field.object(\"id\"); Default Values​ Default values end-up in your models, your inputs and your forms. They are easy and straight forward to work  with. We currently support any JSON compatible object and Date.  field.string(\"firstName\", {   defaultValue: \"John\", \/\/\/ 123, true, }); field.date(\"createOn\", {   defaultValue: new Date(), }); \\n\\n\n"}
{"prompt":" How are nested fields generated and how to work with nested fields in blueprint?  ->","completion":" Nested Fields: ​ You can benefit of nested fields which act as sub models, don't worry, the form will properly generate your  code so you don't have to think about it.  field({   id: \"profile\",   type: field.types.OBJECT,   subfields: [field({ id: \"firstName\", type: field.types.STRING, }),     field({ id: \"lastName\",  type: field.types.STRING,     }),   ], }); Assuming we add this field in Users collection, this would create a new type in GraphQL UserProfile and a  new class with validation UserProfile, you don't even have to think about it. And ofcourse it works with  arrays too. \\n \\n\n"}
{"prompt":" How enums work in blueprint?  ->","completion":" Enums​:  Enums are great especially when your field belongs to a set of values:  field({   id: \"status\",   type: field.types.ENUM,   enumValues: [`IN_PROGRESS`, `ACTIVE`, `CLOSED`], }); Assuming we add this field in Tasks collection it will create a proper TS enum: TaskStatus and inside the  forms it will be a select dropdown option. You can also make it an array.  Enums can also be configured better, especially if you want to add them a comment or modify their  database-store value:  field({   id: \"status\",   type: field.types.ENUM,   enumValues: [{ id: \"IN_PROGRESS\",  value: \"IP\", \/\/ this gets saved in db       label: \"In Progress\", \/\/ this is how it shows on the UI and creates the propper lables  \\n description: \"This means the the task is in progress\", \/\/ gets a comment in TS model and GraphQL API     },   ], }); \\n\\n\n"}
{"prompt":" How reducers work in blueprint? ->","completion":" Reducers​: \\n Reducers are Nova's way of computing values based on certain dependencies:  field({   id: \"fullName\",   type: field.types.STRING,   isReducer: true,   reducerDependency: {     profile: {       firstName: 1,       lastName: 1,},  }, }); \\n Here comes an interesting thing. Reducers will be stored inside collections\/Users\/Users.reducers.ts, however  the logic, the actual function, you'll have to write it yourself in there. This won't be overriden on  subsequent generations as it will check if it exists. \\n This is an intentional limitation of Blueprint,  as we don't want to gobble it with a lot of functionality, plus, reducers can get very complex, however  it's important to have them here because they can appear inside Lists, View, and when you are selecting  remote data (example you want to assign an Invoice to a User, and you display fullName of those users). \\n\\n\n"}
{"prompt":" How to create relations and work with relations in blueprint?  ->","completion":" Relations​: Relations are described the same way Nova relations are, they are stored at collection level under relations:  [], like this:  app({   collections: [ collection({id: \"Comments\", fields: [], relations: [ \/\/ By default it will create the field `postId` of type ObjectID \/\/  \\n If you add `isMany: true` to the config, it will create `postIds` of type Array<ObjectID>` \\n relation({ id: \"post\", to: \"Posts\",}), ],}), collection({ id: \"Posts\",  fields: [], \/\/ \\n some fields  relations: [ relation({ to: \"Comments\",  inversedBy: \"post\", \/\/ the \"id\" of the other's side link}), ],}),], }); \\n If you understand how Nova works, it should be straight forward to understand how these links are described. \\n\\n\n"}
{"prompt":" How to render relations in blueprint?  ->","completion":" Rendering​: So, relations have an additional field which we call representedBy this basically means, if I have a  Post and I have a post owner which is a User how do I show that user? Do I show his id, what fields from  user do I show? And the typical answer is either a specific field that indifies it or a reducer.  This helps the UI Lists to properly render data and know what to query.  relation({   id: \"owner\",   to: \"Owner\",   representedBy: \"fullName\", }); \\n\\n\n"}
{"prompt":" How to create and work with shared models and enums in blueprint?  ->","completion":" Shared Models & Enums​: \\n Shared models are very useful especially when you have the same type of data in multiple collections.  A very common use case is Address: app({sharedModels: [sharedModel({id: \"Address\", fields: [\/\/ Normal field configuration as you're used to],}), sharedModel({ id: \"GenericStatus\", enumValues: [\"TO_DO\", \"IN_PROGRESS\"], \/\/ same as enum })],   collections: [ collection({id: \"Orders\",fields: [ field({ id: \"customerAddress\",  type: field.types.OBJECT,  model: \"Address\", \/\/ you can also use a reference to an actual sharedModel or a function that            \/\/ returns it (useful for file splitting)}),field.enum(\"status\", {  model: \"GenericStatus\", \/\/ or () => GenericStatus if you separated it in another file}), ], }), ], }); \\n So there are two steps, you define the shared models at application level, then you choose which field  represents it. The model definition is stored separate and re-used by all, including validation and everything  you would expect. \\n\\n\n"}
{"prompt":" Describe some possible customizations in blueprint:  ->","completion":" Let's explore the types of customisations we can easily do:  \\n Forms, Lists, Views​: Our Form Schema resides in {Collection}Management\/config\/{Entity}CreateForm.base.tsx. We do our modifications  inside  {Collection}Management\/config\/{Entity}CreateForm.tsx.  {Entity}CreateForm.tsx build() {   super.build();\/\/  \\nFor example you want the description to become a TextArea instead of an input   this.update(\"description\", {render() {return <Ant.Form.Item><TextArea \/><\/Ant.Form.Item> }, \/\/  \\nAny other value as accepted by the Consumer \/\/ \\n You can also configure the order they are presented in     order: 1,   }) } This exact same concept is applied to all forms and all views.\n"}
{"prompt":" Describe some possible customizations in blueprint:  ->","completion":" If you want to request new fields from the API or remove certain fields, you have two options:  Remove them from blueprint's ui Remove them from the consumer and from the requestBody Edit forms, lists, views do requests. This request is done via static getRequestBody() which is a Nova  Request Body.  To customise this request to fit your needs:  class SampleForm {   static getRequestBody(): \\n\\n QueryBodyType<ProjectsAsset> {\/\/ You have the ability to modify the request by adding certain fields or relations     const requestBody = super.getRequestBody(); Object.assign(requestBody, {newField: 1,}); return requestBody;   } }\n"}
{"prompt":" Describe how to customize menus in blueprint:  ->","completion":" Menus​: You have the ability to configure the icon from @ant-design\/icons easily via collection.ui.icon, but if you  want a custom icon to the menu:  If you want to customise the label either you do it via blueprint, or by configuring the translation of it  inside ${Collection}Management\/i18n.ts for management.projects_assets.menu.title  {CollectionManagement}\/routes.tsx import { MyIconSvg } from \"...\";  \\n export const PROJECTS_ASSETS_LIST = {   ...BASE_PROJECTS_ASSETS_LIST,   menu: {     ...BASE_PROJECTS_ASSETS_CREATE.menu,     icon: MyIconSvg,   }, };  n\\ If you want to add the menu as a submenu, we use the inject functionality:  import { MyIconSvg } from \"...\";  export const PROJECTS_LABELS_LIST = {   ...BASE_PROJECTS_LABELS_LIST,   menu: {     ...BASE_PROJECTS_LABELS_LIST.menu,     inject: \"PROJECTS_ASSETS_LIST\", \/\/ This would appear as a submenu under the \"Project Assets\"   }, }; }); \\n\\n\n"}
{"prompt":" Pre-requisites for building a project in blueprint:  ->","completion":" 1. Have node.js 14+ and mongodb installed \\n 2. Have mongodb service running. \\n\\n\n"}
{"prompt":" Create a new project:  ->","completion":" 1. npm i -g i -g bluelibs\/x (installs the x framework) \\n  2. x then choose x:project (creates a project using x) \\n 3. cd project npm install \\n\\n\n"}
{"prompt":" Create the basic structure of the project:  ->","completion":" npm run blueprint:generate \\n  This creates two microservices: api, which contains MongoDB and graphQL interfaces powered by XFramework and the admin powered by Webpack,  React and Ant Design \\n\\n\n"}
{"prompt":" Customize the api for example for a TO DO list api:  ->","completion":" 1. under blueprint\/collections : edit User.ts as needed (add fields, relations, behaviors etc) \\n 2. create a collection in blueprint\/collections and add fields, for example: collection({ id: \"Tasks\", description: \"A collection for TO DO list items\", fields: [ \/\/ Here we specify the fields for collection field({ id: \"title\", type: fields.types.STRING, }),  field({ id: \"description\", type: fields.types.STRING, }),  field({ id: \"softDeadline\", type: fields.types.DATE, }),   field({ id: \"hardDeadline\", type: fields.types.DATE, }),  field({ id: \"createdAt\", type: fields.types.DATE, defaultValue: new Date(), }),],}) \\n\\n\n"}
{"prompt":" Generate the customized project:  ->","completion":" npm run blueprint:generate \\ \n"}
{"prompt":" Add behaviors or relations to the collection: ->","completion":" fill collection({ id: \"Tasks\", relations[] \\n\\n\n"}
